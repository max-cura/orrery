comparison:
x = Index.index <users> :user_id

x = Index.index_tuned <users> :user_id ConsistencyLevel.Immediate

x = Table.columns <users> [:username, :last_online]
filt = _:last_online >= {param}
y = List.filter x filt
Effect.update (y.item_field _:online_right_now) true


x :: () -> Effect ! <Users>.Record.t
---
x = table("users").index(user_id)

x :: () -> Effect ! <Users>.Record.t
---
x = table("users").index_tuned(user_id, ConsistencyLevel::Immediate)

x :: () -> Effect ! {"username": String, "last_online": u64} list
filt :: {"username": String, "last_online": u64} -> bool
y :: () -> Effect ! {"username": String, "last_online": u64} list
---
users = table("users");
x = users.columns(&["username", "last_online"])
filt = x.ty().item_ty().field_accessor::<U64>("last_online") >= { now - 1000 };
y = List.filter(x, filt)

users = table("users"); // TableRef
update(users.columns(&["last_online"]), users.record_ty().field_accessor::<U64>("last_online") + { 2*60*1000 });

user = table("users").index(user_id); // RowRef
cond(Option.is_none(user), tx::abort(), delete(user))

user = table("users").index(user_id);
cond(Option.is_some(table("spammers").index(user_id)), #update(user.field("username"), String.append(partial(), {"_spammer"})), tx::abort())

Effect<(), {Ins(users, {})} ! ()>
---
table("users").insert(&[("username", "user1", "last_online": {now}]);

Effect<I, O> represents #i ! I -> #o ! O

// CLIENT REPRESENTATION:

table(&str) -> Table
Table.index(Value) -> Effect<(), Record>
Table.columns(Value) -> Effect<(), List<Record>>

Record.ty -> RecordTy
 -- runtime type assertion
RecordTy.field_accessor<U: Ty>(&str) -> Effect<Record, U>
Effect<Record, U> >= { u64 -> U } -> Effect<Record, Bool>

List.filter(Effect<(), List<T>>, Effect<T, Bool>) -> Effect<(), List<T>>

problem: actual side effect representation
needs to represent temporal ordering
easiest:
    composition implies an ordering

so we can produce a list of reads and writes:
