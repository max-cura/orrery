we have a set of transactions T1...Tn
for each Ti, we have R(Ti) and W(Ti).

A(Ti) := R(Ti) \cup W(Ti)
w(rj) := { Ti | rj \in W(Ti) }
r(rj) := { Ti | rj \in R(Ti) }

We wish to find a set of partitions P1..Pm so that:

    if Ti in Pi, then no member of W(Ti) appears in any Pj, j \neq i.

Furthermore, the set of { Pi, ... } must be deterministic!

naive (non-deterministic) algorithm:

when transaction T comes in, for each item in A(T), add it to the access bank

-- note: we only consider rows that are in the write set of some transaction
for all transactions, calculate the intersection set
put W(T1) into P1
for all Tj > Tk that intersect Qk_i
    if adding Ti to P1 satisfies the partition size constraint then
        add Ti to P1
    else
        remove Ti from the candidate list and put it on the reject list
repeat to generate P2, except starting from the first Tj that isn't in P1
repeat ... until the candidate list is empty

This works, and is deterministic; however it is only correct if running in a singlethreaded environment!
partially deterministic algorithm:

when transaction T comes in, for each item in A(T), add it to the access bank

for all transactions, calculate the intersection set
divide transactions into N chunks C1...CN
parallel:
    Ck <- any chunk
    while Ck is not empty
        create partition Qk_i
        Tk <- first item remaining in Ck
        add Tk to Qk_i
        for all Tj > Tk that intersect Qk_i
            if adding Tj to Qk_i satisfies the partition size constraint then
                remove Ti from Ck and add it to Qk_i
            else
                remove Ti from the candidate list and put it on the reject list
barrier
// actually, stitching partitions together is a bit too difficult?